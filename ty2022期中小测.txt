"""
a.1两两计算数据的最大公约数。 
【编程要求】
1.编写计算两个整数的最大公约数的函数gcd(x, y)，要求自定义gcd()函数，将结果返回；
2.编写主模块，在主模块中输入多行正整数字符串直到-1结束，调用gcd()函数两两计算这些整数的最大公约数，若原数据文件中的整数个数是奇数个，则最后一个数的最大公约数为1，将结果按“测试数据与运行结果”格式输出。
【测试数据与运行结果】
输入：
15
25
14
112
480
64
1234
-1
输出：
gcd(15,25)=5
gcd(14,112)=14
gcd(480,64)=32
gcd(1234,1)=1
"""

# 最大公约数判定 即 gcd 函数， 每个人都应该熟练写出来，同样的还有 质数判定函数 isPrime
def gcd(x, y):       
    while x % y:
        r = x % y
        x = y
        y = r
    return y



if __name__ == '__main__':
    data = []
    # 同样，实现输入多行，直到 -1 时结束，平时作业写过类似的，例如输入空行结束
    while True:                    
        x = int(input())
        if x != -1:
            data.append(x)
        else:
            break
    n = len(data)                    
    data.append(1) if n % 2 else data    # 题目要求提到 若为奇数 应当最后一个数的最大公约数为1，则需要进行对应处理
    for i in range(0, len(data), 2):       # 题目要求两两求最大公约数
        x = gcd(data[i], data[i + 1])    
        print('gcd({},{})=({})'.format(data[i], data[i + 1], x))  
    
"""
a.2输入一个英文单词，先将其转化为小写字母，查找其中不含有重复字符的最长字符子串，并输出其长度。例如，输入单词为"anaconda"，其中无重复字符的最长子串是 "acond"、"conda"，其长度为 5。
【测试数据与运行结果】
输入：
Anaconda
输出: 
5
"""

s = input().lower()    # 题目明确提出了 --> 输入 转小写
# 寻找不含有重复字符的最长字符字串
# 则这里应该思考两个地方：子串从何处开始，何处结束？结束位置与开始位置相减即长度
# 因此，循环至少有一层，进行开始位置的尝试
# 其次，需要对可能的结束位置进行尝试，因此需要第二层循环，
# 且第二层循环，应当从第一层循环的 i 开始，因为结束位置不应该早于开始位置
    # 结束位置 取决于是否出现重复 因此每次增加一单位长度，都要进行重复检查，即对下一个字母，判断是否在之前出现过（重复判定的方式很多，这里仅仅是一个举例）
# 这道题个人认为思路比较明确
    # 两层循环标记位置 + 对第二层循环的每个字母进行重复判定
maxs = ''
for i in range(len(s)):      
    temp = ''
    for j in range(i, len(s)):       
      if s[j] not in temp:       
          temp += s[j]
          if len(temp) > len(maxs):     
              maxs = temp
      else:
          break
print(len(maxs))  

"""
a.3【程序功能】
编写程序查找10000以内所有在电子屏上显示的中心对称数。
中心对称数是指一个数字在旋转了180度之后看起来依旧相同的数字（或者上下颠倒地看），在电子显示屏中显示数字时，0，2，5，8是中心对称的（1旋转180度后，显示的位置不对故而剔除），6和9则关于某点成中心对称。
【编程要求】
（1）编写函数judge(n)，函数功能为判断n为中心对称数，是则返回True，否则返回False；
提示：用字典表示对称的数字。

（2）在主模块中遍历10000以内的数，调用judge()函数查找其中的中心对称数，将这些数按10个（最后一行可能不足10个）一行输出，一行内用个逗号间隔数字，格式参考“测试数据与运行结果”。

【测试数据与运行结果】
0,2,5,8,22,55,69,88,96,202
222,252,282,505,525,555,585,609,629,659
689,808,828,858,888,906,926,956,986,2002
2222,2552,2692,2882,2962,5005,5225,5555,5695,5885
5965,6009,6229,6559,6699,6889,6969,8008,8228,8558
8698,8888,8968,9006,9226,9556,9696,9886,9966
"""

# 题目已经明确给出了中心对称数的组合，0：0，2：2，5：5，8：8，6：9，：9：6
# 则寻找中心对称数，即对给定数找到对应的组合 --> 类比给定 name寻找 QQ
# 另一方面，就是回文数的写法了
# 这道题相当于 回文数 题目套了壳，并不是直接相等，而是检查是否是对应的中心对称数

def judge(n):     
    d = {0: 0, 2: 2, 5: 5, 8: 8, 6: 9, 9: 6} 
    s = str(n) 
    for i in range(len(s) // 2):                  
        if int(s[len(s) - 1 - i]) != d.get(int(s[i])): 
            return False
    if len(s) % 2 != 0 and s[len(s) // 2] not in '0258':       
        return False 
    return True           

# 遍历 非常纯粹
# 大家作业也做过了 每行输出10个，不满10则全部输出的题目，
# 因此大家应该能够用join函数 或者 print调整 sep 与 end 进行实现
lst = []
for i in range(10000): 
    if judge(i):  
        lst.append(str(i))
for i in range(0,len(lst),10): 
    print(','.join(lst[i:i+10])) 

